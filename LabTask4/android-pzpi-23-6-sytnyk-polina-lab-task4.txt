Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії







ЗВІТ
до лабораторної роботи 4 з дисципліни
"Програмування під Android"
на тему "Створення нотаток" 







Виконала ст. гр ПЗПІ-23-6
Ситник Поліна


Перевірив 
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2024

МЕТА
     
    Метою цієї лабораторної роботи є ознайомити студентів з основами розробки мобільних додатків для платформи Android. Зокрема, студенти повинні навчитися реалізовувати функціонал для створення, редагування, перегляду та видалення нотаток. Вони також отримають навички роботи з графічними елементами інтерфейсу, такими як іконки, контекстне меню та пошук/фільтрація. Крім того, студенти ознайомляться з принципами локалізації інтерфейсу додатка для підтримки двох мов — української та англійської.

ЗАВДАННЯ

    Розробити застосунок для ведення нотаток.
    
    Застосунок повинен дозволяти переглядати список нотаток, створювати нову нотатку, редагувати нотатку та видаляти нотатку. Кожна нотатка повинна мати назву, опис, важливість (три класи), час і дату призначення і картинку (вибирається з галереї).
    
    У списку нотатки відображаються з іконкою з галереї і часом створення (праворуч зверху більш дрібним шрифтом), а також графічним відображенням класу важливості (іконка з множини).
    
    Потрібно реалізувати функції додавання, видалення, редагування (без збереження між перезапуск додатку) нотаток.
    
    Видалення/редагування викликаються з контекстного меню при довгому натисненні, додавання - з основного меню в ActionBar. У ActionBar реалізувати пошук / фільтрація заміток за змістом тексту, а також фільтрацію за важливістю. Текстові елементи користувацького інтерфейсу повинні бути локалізовані українською та англійською мовами.





ХІД РОБОТИ
Note.java
Клас Note слугує моделлю даних для зберігання інформації про нотатки. Він містить приватні поля для збереження ідентифікатора нотатки, заголовка, опису, рівня важливості, дати та часу створення, а також URI зображення. Клас має конструктор для ініціалізації цих полів і методи доступу (геттери) для отримання значень. Кожна нотатка в додатку є екземпляром цього класу, що дає змогу зберігати необхідну інформацію в базі даних і використовувати її для відображення в інтерфейсі .
AddNoteActivity.java
Клас AddNoteActivity відповідає за процес додавання нової нотатки. Тут реалізовано введення даних користувачем, вибір зображення для нотатки та збереження цих даних у базу даних. Інтерфейс включає поля для введення заголовка та опису, вибір важливості за допомогою Spinner, а також кнопку для додавання зображення. Після натискання кнопки "Save Note" введена інформація зберігається в базі даних, і користувача перенаправляють до головного екрану зі списком нотаток .
MainActivity.java
Цей клас є головною активністю додатка, що відображає всі нотатки у вигляді списку через RecyclerView. MainActivity також надає можливість пошуку нотаток за заголовком через текстове поле, а також містить кнопку для переходу до екрану додавання нової нотатки. Адаптер NotesAdapter відповідає за завантаження нотаток з бази даних і відображення їх у вигляді карток. Користувач може натискати на нотатки для їх перегляду або редагування .
EditNoteActivity.java
Клас EditNoteActivity дає можливість редагувати вже існуючі нотатки. У цьому класі користувач може змінювати заголовок, опис, рівень важливості та зображення нотатки. Також передбачена функція видалення нотатки через кнопку "Delete Note". Після редагування користувач може зберегти зміни в базі даних або видалити нотатку, після чого його перенаправляють до головного списку.
DatabaseHelper.java
Цей клас відповідає за роботу з базою даних SQLite. Він містить методи для створення таблиці нотаток і виконання операцій додавання, оновлення, видалення та отримання списку нотаток. У базі даних зберігаються поля: id, title, description, importance, dateTime і imageUri. Клас надає можливість взаємодіяти між основними активностями програми та базою даних .
NotesAdapter.java
Адаптер NotesAdapter відповідає за відображення списку нотаток у RecyclerView. Він формує кожен елемент списку у вигляді картки з інформацією про нотатку: заголовок, опис, дату, рівень важливості та зображення. Крім того, реалізовано інтерфейс OnNoteClickListener для обробки натискання на нотатки .


ВИСНОВКИ     
У результаті виконання лабораторної роботи я набула практичних навичок у розробці мобільних додатків для платформи Android. Також ознайомилася з основними аспектами створення додатків, такими як реалізація функціональності для створення, редагування, перегляду та видалення нотаток. Здобула досвід роботи з графічними елементами інтерфейсу, зокрема з іконками, контекстними меню та механізмами пошуку й фільтрації даних.
     Посилання на відео в YouTube: https://youtu.be/exYxVSctDXs

ВИКОРИСТАННІ ДЖЕРЕЛА
1. Національний університет радіоелектроніки. https://dl.nure.ua/. Дата доступу: 17 грудня 2024 року.




ДОДАТОК А
Файл MainActivity.java
package nure.sytnyk.polina.lab4;
import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.provider.MediaStore;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.View;
import android.widget.EditText;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.util.ArrayList;

public class MainActivity extends AppCompatActivity implements NotesAdapter.OnNoteClickListener {

    private static final int PICK_IMAGE_REQUEST = 1;
    private static final int ADD_NOTE_REQUEST_CODE = 1;
    private static final int EDIT_NOTE_REQUEST_CODE = 2;

    private RecyclerView recyclerView;
    private NotesAdapter adapter;
    private ArrayList<Note> notesList = new ArrayList<>();
    private ArrayList<Note> originalNotesList = new ArrayList<>();
    private DatabaseHelper databaseHelper;
    private Uri imageUri;
    private EditText searchEditText;

    private ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                if (isGranted) {
                    updateNotesList();
                } else {
                    Toast.makeText(this, "Permission denied. Cannot load images.", Toast.LENGTH_SHORT).show();
                }
            });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        checkAndRequestPermissions();

        recyclerView = findViewById(R.id.recyclerView);
        databaseHelper = new DatabaseHelper(this);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        adapter = new NotesAdapter(this, notesList, this);
        recyclerView.setAdapter(adapter);

        findViewById(R.id.addNoteButton).setOnClickListener(v -> openAddNoteActivity());

        searchEditText = findViewById(R.id.searchEditText);
        searchEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                filterNotes(s.toString());
            }

            @Override
            public void afterTextChanged(Editable s) {}
        });
    }

    private void checkAndRequestPermissions() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(
                    this, Manifest.permission.READ_MEDIA_IMAGES) !=
                    PackageManager.PERMISSION_GRANTED) {
                requestPermissionLauncher.launch(Manifest.permission.READ_MEDIA_IMAGES);
            }
        } else {
            if (ContextCompat.checkSelfPermission(
                    this, Manifest.permission.READ_EXTERNAL_STORAGE) !=
                    PackageManager.PERMISSION_GRANTED) {
                requestPermissionLauncher.launch(Manifest.permission.READ_EXTERNAL_STORAGE);
            }
        }
    }

    private void filterNotes(String searchText) {
        if (originalNotesList.isEmpty()) {
            originalNotesList.addAll(notesList);
        }

        notesList.clear();

        if (searchText.isEmpty()) {
            notesList.addAll(originalNotesList);
        } else {
            for (Note note : originalNotesList) {
                if (note.getTitle().toLowerCase().contains(searchText.toLowerCase())) {
                    notesList.add(note);
                }
            }
        }

        adapter.notifyDataSetChanged();
    }

    private void updateNotesList() {
        notesList.clear();
        originalNotesList.clear();
        notesList.addAll(databaseHelper.getAllNotes());
        originalNotesList.addAll(notesList);
        adapter.notifyDataSetChanged();
    }

    @Override
    protected void onStart() {
        super.onStart();
        updateNotesList();
    }

    private void openAddNoteActivity() {
        Intent intent = new Intent(this, AddNoteActivity.class);
        startActivityForResult(intent, ADD_NOTE_REQUEST_CODE);
    }

    @Override
    public void onNoteClick(Note note) {
        Intent intent = new Intent(this, EditNoteActivity.class);
        intent.putExtra("note_id", note.getId());
        intent.putExtra("title", note.getTitle());
        intent.putExtra("description", note.getDescription());
        intent.putExtra("importance", note.getImportance());
        intent.putExtra("image_uri", note.getImageUri() != null ? note.getImageUri().toString() : "");

        startActivityForResult(intent, EDIT_NOTE_REQUEST_CODE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null) {
            imageUri = data.getData();
        }

        if ((requestCode == ADD_NOTE_REQUEST_CODE || requestCode == EDIT_NOTE_REQUEST_CODE)
                && resultCode == RESULT_OK) {
            updateNotesList();
        }
    }
}















ДОДАТОК Б
Файл Note.java
package nure.sytnyk.polina.lab4;
import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.provider.MediaStore;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.View;
import android.widget.EditText;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.util.ArrayList;

public class MainActivity extends AppCompatActivity implements NotesAdapter.OnNoteClickListener {

    private static final int PICK_IMAGE_REQUEST = 1;
    private static final int ADD_NOTE_REQUEST_CODE = 1;
    private static final int EDIT_NOTE_REQUEST_CODE = 2;

    private RecyclerView recyclerView;
    private NotesAdapter adapter;
    private ArrayList<Note> notesList = new ArrayList<>();
    private ArrayList<Note> originalNotesList = new ArrayList<>();
    private DatabaseHelper databaseHelper;
    private Uri imageUri;
    private EditText searchEditText;

    private ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                if (isGranted) {
                    updateNotesList();
                } else {
                    Toast.makeText(this, "Permission denied. Cannot load images.", Toast.LENGTH_SHORT).show();
                }
            });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        checkAndRequestPermissions();

        recyclerView = findViewById(R.id.recyclerView);
        databaseHelper = new DatabaseHelper(this);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        adapter = new NotesAdapter(this, notesList, this);
        recyclerView.setAdapter(adapter);

        findViewById(R.id.addNoteButton).setOnClickListener(v -> openAddNoteActivity());

        searchEditText = findViewById(R.id.searchEditText);
        searchEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                filterNotes(s.toString());
            }

            @Override
            public void afterTextChanged(Editable s) {}
        });
    }

    private void checkAndRequestPermissions() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(
                    this, Manifest.permission.READ_MEDIA_IMAGES) !=
                    PackageManager.PERMISSION_GRANTED) {
                requestPermissionLauncher.launch(Manifest.permission.READ_MEDIA_IMAGES);
            }
        } else {
            if (ContextCompat.checkSelfPermission(
                    this, Manifest.permission.READ_EXTERNAL_STORAGE) !=
                    PackageManager.PERMISSION_GRANTED) {
                requestPermissionLauncher.launch(Manifest.permission.READ_EXTERNAL_STORAGE);
            }
        }
    }

    private void filterNotes(String searchText) {
        if (originalNotesList.isEmpty()) {
            originalNotesList.addAll(notesList);
        }

        notesList.clear();

        if (searchText.isEmpty()) {
            notesList.addAll(originalNotesList);
        } else {
            for (Note note : originalNotesList) {
                if (note.getTitle().toLowerCase().contains(searchText.toLowerCase())) {
                    notesList.add(note);
                }
            }
        }

        adapter.notifyDataSetChanged();
    }

    private void updateNotesList() {
        notesList.clear();
        originalNotesList.clear();
        notesList.addAll(databaseHelper.getAllNotes());
        originalNotesList.addAll(notesList);
        adapter.notifyDataSetChanged();
    }

    @Override
    protected void onStart() {
        super.onStart();
        updateNotesList();
    }

    private void openAddNoteActivity() {
        Intent intent = new Intent(this, AddNoteActivity.class);
        startActivityForResult(intent, ADD_NOTE_REQUEST_CODE);
    }

    @Override
    public void onNoteClick(Note note) {
        Intent intent = new Intent(this, EditNoteActivity.class);
        intent.putExtra("note_id", note.getId());
        intent.putExtra("title", note.getTitle());
        intent.putExtra("description", note.getDescription());
        intent.putExtra("importance", note.getImportance());
        intent.putExtra("image_uri", note.getImageUri() != null ? note.getImageUri().toString() : "");

        startActivityForResult(intent, EDIT_NOTE_REQUEST_CODE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null) {
            imageUri = data.getData();
        }

        if ((requestCode == ADD_NOTE_REQUEST_CODE || requestCode == EDIT_NOTE_REQUEST_CODE)
                && resultCode == RESULT_OK) {
            updateNotesList();
        }
    }
}























ДОДАТОК В
Файл NotesAdapter.java
package nure.sytnyk.polina.lab4;
import android.content.Context;
import android.graphics.Bitmap;
import android.provider.MediaStore;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import java.io.IOException;
import java.util.ArrayList;

public class NotesAdapter extends RecyclerView.Adapter<NotesAdapter.NoteViewHolder> {

    private Context context;
    private ArrayList<Note> notesList;
    private OnNoteClickListener onNoteClickListener;

    public NotesAdapter(Context context, ArrayList<Note> notesList, OnNoteClickListener onNoteClickListener) {
        this.context = context;
        this.notesList = notesList;
        this.onNoteClickListener = onNoteClickListener;
    }

    @NonNull
    @Override
    public NoteViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(context).inflate(R.layout.note_item, parent, false);
        return new NoteViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull NoteViewHolder holder, int position) {
        Note note = notesList.get(position);
        holder.title.setText(note.getTitle());
        holder.description.setText(note.getDescription());
        holder.dateTime.setText(note.getDateTime());

        if (note.getImageUri() != null) {
            try {
                Bitmap bitmap = MediaStore.Images.Media.getBitmap(context.getContentResolver(), note.getImageUri());
                holder.image.setImageBitmap(bitmap);
            } catch (IOException e) {
                holder.image.setImageResource(R.drawable.ic_launcher_background);
                e.printStackTrace();
            }
        } else {
            holder.image.setImageResource(R.drawable.ic_launcher_background);
        }

        holder.importance.setImageResource(getImportanceIcon(note.getImportance()));

        holder.itemView.setOnClickListener(v -> onNoteClickListener.onNoteClick(note));
    }

    @Override
    public int getItemCount() {
        return notesList.size();
    }

    private int getImportanceIcon(int importance) {
        switch (importance) {
            case 1:
                return R.drawable.low_importance;
            case 2:
                return R.drawable.medium_importance;
            case 3:
                return R.drawable.high_importance;
            default:
                return R.drawable.low_importance;
        }
    }
    public interface OnNoteClickListener {
        void onNoteClick(Note note);
    }

    public static class NoteViewHolder extends RecyclerView.ViewHolder {

        TextView title, description, dateTime;
        ImageView image, importance;

        public NoteViewHolder(View itemView) {
            super(itemView);
            title = itemView.findViewById(R.id.title);
            description = itemView.findViewById(R.id.description);
            dateTime = itemView.findViewById(R.id.dateTime);
            image = itemView.findViewById(R.id.image);
            importance = itemView.findViewById(R.id.importance);
        }
    }
}

ДОДАТОК Г
Файл AddNoteActivity.java
package nure.sytnyk.polina.lab4;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.provider.MediaStore;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.Spinner;
import android.widget.Toast;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class AddNoteActivity extends AppCompatActivity {

    private static final int PICK_IMAGE_REQUEST = 1;

    private EditText titleEditText, descriptionEditText;
    private Spinner importanceSpinner;
    private Button saveButton, selectImageButton;
    private ImageView noteImageView;
    private Uri imageUri;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_add_note);

        titleEditText = findViewById(R.id.titleEditText);
        descriptionEditText = findViewById(R.id.descriptionEditText);
        importanceSpinner = findViewById(R.id.importanceSpinner);
        saveButton = findViewById(R.id.saveButton);
        selectImageButton = findViewById(R.id.selectImageButton);
        noteImageView = findViewById(R.id.noteImageView);

        selectImageButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                openGallery();
            }
        });

        saveButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                saveNote();
            }
        });
    }

    private void openGallery() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, PICK_IMAGE_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null && data.getData() != null) {
            imageUri = data.getData();
            noteImageView.setImageURI(imageUri);
        }
    }

    private void saveNote() {
        String title = titleEditText.getText().toString().trim();
        String description = descriptionEditText.getText().toString().trim();
        int importance = importanceSpinner.getSelectedItemPosition();
        String dateTime = new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault()).format(new Date());
        String imageUriString = (imageUri != null) ? imageUri.toString() : "";

        if (title.isEmpty() || description.isEmpty()) {
            Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
        } else {
            DatabaseHelper dbHelper = new DatabaseHelper(this);
            long noteId = dbHelper.addNote(title, description, importance, dateTime, imageUriString);

            if (noteId != -1) {
                Toast.makeText(this, "Note added successfully", Toast.LENGTH_SHORT).show();
                finish();
            } else {
                Toast.makeText(this, "Error adding note", Toast.LENGTH_SHORT).show();
            }
        }
    }
}
ДОДАТОК Д
Файл EditNoteActivity.java
package nure.sytnyk.polina.lab4;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.provider.MediaStore;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.Spinner;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

public class EditNoteActivity extends AppCompatActivity {

    private static final int PICK_IMAGE_REQUEST = 1;

    private EditText titleEditText, descriptionEditText;
    private Spinner importanceSpinner;
    private Button saveButton, selectImageButton, deleteButton;
    private ImageView noteImageView;
    private Uri imageUri;
    private DatabaseHelper dbHelper;
    private long noteId;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_edit_note);

        dbHelper = new DatabaseHelper(this);

        titleEditText = findViewById(R.id.titleEditText);
        descriptionEditText = findViewById(R.id.descriptionEditText);
        importanceSpinner = findViewById(R.id.importanceSpinner);
        saveButton = findViewById(R.id.saveButton);
        selectImageButton = findViewById(R.id.selectImageButton);
        deleteButton = findViewById(R.id.deleteButton);
        noteImageView = findViewById(R.id.noteImageView);

        // Получаем данные из Intent
        Intent intent = getIntent();
        noteId = intent.getLongExtra("note_id", -1);
        String title = intent.getStringExtra("title");
        String description = intent.getStringExtra("description");
        int importance = intent.getIntExtra("importance", 0);
        String imageUriString = intent.getStringExtra("image_uri");

        // Заполняем поля
        titleEditText.setText(title);
        descriptionEditText.setText(description);
        importanceSpinner.setSelection(importance);

        if (imageUriString != null && !imageUriString.isEmpty()) {
            imageUri = Uri.parse(imageUriString);
            noteImageView.setImageURI(imageUri);
        }

        selectImageButton.setOnClickListener(v -> openGallery());
        saveButton.setOnClickListener(v -> updateNote());
        deleteButton.setOnClickListener(v -> deleteNote());
    }

    private void openGallery() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, PICK_IMAGE_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null && data.getData() != null) {
            imageUri = data.getData();
            noteImageView.setImageURI(imageUri);
        }
    }

    private void updateNote() {
        String title = titleEditText.getText().toString().trim();
        String description = descriptionEditText.getText().toString().trim();
        int importance = importanceSpinner.getSelectedItemPosition();
        String dateTime = getCurrentDateTime(); // Метод для получения текущей даты
        String imageUriString = (imageUri != null) ? imageUri.toString() : "";

        if (title.isEmpty() || description.isEmpty()) {
            Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
            return;
        }

        int rowsAffected = dbHelper.updateNote(noteId, title, description, importance, dateTime, imageUriString);

        if (rowsAffected > 0) {
            Toast.makeText(this, "Note updated successfully", Toast.LENGTH_SHORT).show();
            Intent resultIntent = new Intent();
            setResult(RESULT_OK, resultIntent);
            finish();
        } else {
            Toast.makeText(this, "Error updating note", Toast.LENGTH_SHORT).show();
        }
    }

    private void deleteNote() {
        dbHelper.deleteNote(noteId);
        Toast.makeText(this, "Note deleted", Toast.LENGTH_SHORT).show();
        Intent resultIntent = new Intent();
        setResult(RESULT_OK, resultIntent);
        finish();
    }

    private String getCurrentDateTime() {
        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm");
        return sdf.format(new java.util.Date());
    }
}


ДОДАТОК Е
Файл DatabaseHelpe.java
package nure.sytnyk.polina.lab4;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.net.Uri;

import java.util.ArrayList;
import java.util.List;

public class DatabaseHelper extends SQLiteOpenHelper {

    private static final String DATABASE_NAME = "notes.db";
    private static final int DATABASE_VERSION = 1;
    public static final String TABLE_NOTES = "notes";
    public static final String COLUMN_ID = "id";
    public static final String COLUMN_TITLE = "title";
    public static final String COLUMN_DESCRIPTION = "description";
    public static final String COLUMN_IMPORTANCE = "importance";
    public static final String COLUMN_DATE_TIME = "dateTime";
    public static final String COLUMN_IMAGE_URI = "imageUri";

    public DatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        String createTableQuery = "CREATE TABLE " + TABLE_NOTES + " ("
                + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, "
                + COLUMN_TITLE + " TEXT, "
                + COLUMN_DESCRIPTION + " TEXT, "
                + COLUMN_IMPORTANCE + " INTEGER, "
                + COLUMN_DATE_TIME + " TEXT, "
                + COLUMN_IMAGE_URI + " TEXT)";
        db.execSQL(createTableQuery);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS " + TABLE_NOTES);
        onCreate(db);
    }

    public long addNote(String title, String description, int importance, String dateTime, String imageUri) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(COLUMN_TITLE, title);
        values.put(COLUMN_DESCRIPTION, description);
        values.put(COLUMN_IMPORTANCE, importance);
        values.put(COLUMN_DATE_TIME, dateTime);
        values.put(COLUMN_IMAGE_URI, imageUri);

        long id = db.insert(TABLE_NOTES, null, values);
        db.close();
        return id;
    }

    public List<Note> getAllNotes() {
        List<Note> notesList = new ArrayList<>();
        SQLiteDatabase db = this.getReadableDatabase();
        Cursor cursor = db.rawQuery("SELECT * FROM " + TABLE_NOTES, null);

        if (cursor != null && cursor.moveToFirst()) {
            do {
                int idIndex = cursor.getColumnIndex(COLUMN_ID);
                int titleIndex = cursor.getColumnIndex(COLUMN_TITLE);
                int descriptionIndex = cursor.getColumnIndex(COLUMN_DESCRIPTION);
                int importanceIndex = cursor.getColumnIndex(COLUMN_IMPORTANCE);
                int dateTimeIndex = cursor.getColumnIndex(COLUMN_DATE_TIME);
                int imageUriIndex = cursor.getColumnIndex(COLUMN_IMAGE_URI);

                if (idIndex != -1 && titleIndex != -1 && descriptionIndex != -1 &&
                        importanceIndex != -1 && dateTimeIndex != -1 && imageUriIndex != -1) {

                    long id = cursor.getLong(idIndex);
                    String title = cursor.getString(titleIndex);
                    String description = cursor.getString(descriptionIndex);
                    int importance = cursor.getInt(importanceIndex);
                    String dateTime = cursor.getString(dateTimeIndex);
                    String imageUriString = cursor.getString(imageUriIndex);

                    Uri imageUri = null;
                    if (imageUriString != null && !imageUriString.isEmpty()) {
                        try {
                            imageUri = Uri.parse(imageUriString);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }

                    Note note = new Note(id, title, description, importance, dateTime, imageUri);
                    notesList.add(note);
                }

            } while (cursor.moveToNext());

            cursor.close();
        }
        db.close();
        return notesList;
    }

    public int updateNote(long id, String title, String description, int importance, String dateTime, String imageUri) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(COLUMN_TITLE, title);
        values.put(COLUMN_DESCRIPTION, description);
        values.put(COLUMN_IMPORTANCE, importance);
        values.put(COLUMN_DATE_TIME, dateTime);
        values.put(COLUMN_IMAGE_URI, imageUri);

        int rowsAffected = db.update(TABLE_NOTES, values, COLUMN_ID + " = ?", new String[]{String.valueOf(id)});
        db.close();
        return rowsAffected;
    }

    public void deleteNote(long id) {
        SQLiteDatabase db = this.getWritableDatabase();
        db.delete(TABLE_NOTES, COLUMN_ID + " = ?", new String[]{String.valueOf(id)});
        db.close();
    }

    public void deleteAllNotes() {
        SQLiteDatabase db = this.getWritableDatabase();
        db.delete(TABLE_NOTES, null, null);
        db.close();
    }
}

